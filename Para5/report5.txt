--------------------------

学籍番号 : 0000000
氏名 :

--------------------------

回答1 :
1.1) 空欄に入る数は以下のとおり

A：255*255*255
そのように考えた理由：
r255 g255 b255

B:4*4*4
そのように考えた理由：
qcount = 4, n = qcount*qcount*qcount
sample[n]. everty pixel will choose the closest colour in sample

C:
そのように考えた理由：
qcount = 4, n = qcount*qcount*qcount
sample[n]. everty pixel will choose the closest colour in sample
but the color in sample will be different from B

1.2)
並列化で問題となるStreamの処理の番号

the no.1 stream 


1.3)単純に並列化したのでは結果が異なる原因

the ave object is shared by all threads. and all threads will change the content of ave.


1.4)並列化に対応するために行った変更点

    //2番目のParallelStream処理
    IntStream.range(0,SCOUNT3).parallel().
    forEach(n->{
        RGB rgb = ave.get(n);
        // use the classified colors to make a new sample
        sample[n] = rgb.get();
    });

    //3番目のParallelStream処理
    Map<Integer,Integer> classified =
    IntStream.range(0,Camera.WIDTH*Camera.HEIGHT)
              .boxed()
              .parallel()
              .collect(Collectors.toMap(n->n,
                  n->{int min=600000;
                  int label=0;
                  for(int j=0;j<sample.length;j++){
                    int dp = distancepow(inimage[n], sample[j]);
                      if(dp < min){
                        label=j;
                        min = dp;
                      }
                    }
                  return label;
              }));




回答2 :
2.1)
出力される時間の意味



達成された高速化の数値的説明





計測時間の信頼性を向上させるために行った工夫、計測で注意した点





2.2)
衝突判定部分の高速化についてのjvisualvmを使用した調査方法の説明





調査により判明した衝突判定部分の高速化前後の処理速度の比率







2.3)
発見された改善対象のコード部分





改良方針





2.4)2.3で行った改良部分の改良前後の処理時間について

処理時間の定義




改良前と比べ改良後の処理時間は　　　　％となった



回答3 :
3.1)ゲーム性を高めるための実装
得点ルールの定義




得点計算のコード部分について




得点表示のためのコード部分について




ゲームの終了条件の定義




ゲームの終了判定のコード部分について





スタートボタンを押した際の新たな初期化処理について






ゲームの難易度の方針





数値選択とゲーム難易度についての実装部分について






3.2)さらなるゲーム性を高めるための実装
実装方針




実装箇所







今回の課題で特に学べたと感じたこと

